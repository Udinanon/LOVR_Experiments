// local workgroup size
layout(local_size_x = 16, local_size_y = 16) in;
// set 0 1nd 1 are occupied only on Vertex and Fragment shaders
layout(set = 0, binding = 0, rgba8) uniform image2D image;
layout(set = 0, binding = 0, rgba8) uniform image2D out_image;

#define KERNEL_SIZE 9

void lovrmain() {
    float Kernel[KERNEL_SIZE] = {0., -1., -0., 
                                 -1., 5., -1., 
                                 0., -1., -0.}; 
    
    ivec2 KernelOffsets[KERNEL_SIZE] = {ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
                                        ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0), 
                                        ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1)};

    ivec2 size = imageSize(image);
    ivec2 pixel = ivec2(GlobalThreadID.xy);

    // Skip if position does not exist in image
    if (pixel.x >= (size.x) || pixel.y >= (size.y) || pixel.x < 0 || pixel.y < 0) {
        return;
    }
    int i = 0;
    vec4 final_color = vec4(0.0);
   
    for(i = 0; i < KERNEL_SIZE; i++ ){
        vec4 tmp = vec4(0);
        // check that pixel to read exists
        if (!((pixel + KernelOffsets[i]).x >= (size.x) || (pixel + KernelOffsets[i]).y >= (size.y) || (pixel + KernelOffsets[i]).x < 0 || (pixel + KernelOffsets[i]).y < 0)) {
            tmp = imageLoad(image, pixel + KernelOffsets[i]);
        }
        final_color += tmp * Kernel[i];
    }

    imageStore(out_image, pixel, final_color);
}